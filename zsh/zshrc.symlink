## Path
# Default path
export PATH="/sbin"
PATH="/usr/sbin:$PATH"
PATH="/bin:$PATH"
PATH="/usr/bin:$PATH"
PATH="/usr/local/sbin:$PATH"
PATH="/usr/local/bin:$PATH"

# LaTeX!
PATH="/usr/texbin:$PATH"

# Local path
PATH="$HOME/dotfiles/bin:$PATH"

# Composer (PHP)
PATH="$HOME/.composer/vendor/bin:$PATH"

# Python
export PYTHONPATH="$PYTHONPATH:$HOME/dotfiles/lib/python"

## Completion

# Load up the extra Z Shell completions
fpath=("$HOME/.zsh/zsh-completions/src" $fpath)

# Ensure we can run the compinit to make them work.
autoload compinit

# Initialise better autocompletion
compinit

## Syntax Highlighting

source "$HOME/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"

# Make errors red
ZSH_HIGHLIGHT_STYLES[unknown-token]='fg=red'

# Turn just about everything else off
ZSH_HIGHLIGHT_STYLES[reserved-word]='none'
ZSH_HIGHLIGHT_STYLES[reserved-word]='none'
ZSH_HIGHLIGHT_STYLES[alias]='none'
ZSH_HIGHLIGHT_STYLES[builtin]='none'
ZSH_HIGHLIGHT_STYLES[function]='none'
ZSH_HIGHLIGHT_STYLES[command]='none'
ZSH_HIGHLIGHT_STYLES[precommand]='none'
ZSH_HIGHLIGHT_STYLES[commandseparator]='none'
ZSH_HIGHLIGHT_STYLES[hashed-command]='none'
ZSH_HIGHLIGHT_STYLES[path]='none'
ZSH_HIGHLIGHT_STYLES[path_prefix]='none'
ZSH_HIGHLIGHT_STYLES[path_approx]='none'
ZSH_HIGHLIGHT_STYLES[globbing]='none'
ZSH_HIGHLIGHT_STYLES[history-expansion]='none'
ZSH_HIGHLIGHT_STYLES[single-hyphen-option]='none'
ZSH_HIGHLIGHT_STYLES[double-hyphen-option]='none'
ZSH_HIGHLIGHT_STYLES[back-quoted-argument]='none'
ZSH_HIGHLIGHT_STYLES[single-quoted-argument]='none'
ZSH_HIGHLIGHT_STYLES[double-quoted-argument]='none'
ZSH_HIGHLIGHT_STYLES[dollar-double-quoted-argument]='none'
ZSH_HIGHLIGHT_STYLES[back-double-quoted-argument]='none'
ZSH_HIGHLIGHT_STYLES[assign]='none'
ZSH_HIGHLIGHT_STYLES[default]='none'

# Get the first part of the hostname
#
# Sometimes they have dots in them, I'm not partial to that.
function nice-hostname {
  echo $(command hostname | cut -d . -f 1)
}

## Feature Colors
#
# These are used in the prompt and Tmux status bar as a reminder of
# where we are.

declare -A FEATURE_COLORS
FEATURE_COLORS=(
  kronecker green
  galois cyan
  dirac magenta
  hilbert blue
)

COLOR_NAME="$FEATURE_COLORS[$(nice-hostname)]"
COLOR="$fg[$COLOR_NAME]"

## Git

# Show the current Git branch.
#
# If we are not on a branch, print the short ref.
function git-prompt-info {
  REF=$(command git current-branch 2> /dev/null) || \
  REF=$(command git rev-parse --short HEAD 2> /dev/null) || return 0
  COLOR="$fg[$FEATURE_COLORS[$(nice-hostname)]]"
  echo "($COLOR$REF$reset_color)"
}

# Keep track of editing mode.
#
# Since I use Vi key bindings, I need a way to know which editing mode
# I am in.

EDITING_MODE="I"

function set-editing-mode {
  EDITING_MODE="$1"
}

function get-editing-mode {
  echo "$EDITING_MODE"
}

## Prompt

# Autoload colors so we can make the prompt green.
autoload -U colors && colors

# We set the prompt in the line editor function.

## SSH Agent

# Start SSH Agent and set relevant variables
function start-agent {
  echo "Initialising new SSH Agent..."
  rm ~/.ssh/redbox-docker-socket
  ssh-agent -s -a $HOME/.ssh/redbox-docker-socket | sed 's/^echo/# echo/' > "$SSH_ENV"
  echo "Success!"
  chmod 600 "$SSH_ENV"
  . $SSH_ENV > /dev/null
  ssh-add "$HOME/.ssh/id_$(nice-hostname)"
}

# If we may have loaded config, let's just check that
function test-identities {
  if ! ssh-add -l > /dev/null; then
    start-agent
  fi
}

# Start SSH Agent if it's not already running.
#
# Also add the id_(nice-hostname) identity.
export SSH_ENV="$HOME/.ssh/environment"
if [[ -f $SSH_ENV ]]; then
  . $SSH_ENV > /dev/null
  test-identities
else
  start-agent
fi

## Line Editing

# Use Vi key bindings rather than emacs.
bindkey -v

# Don't beep at me when I do something wrong.
#
# I found it was beeping when I wasn't doing something wrong, and that
# really gets on my nerves.
setopt no_beep

# Add my shortcut for escape.
#
# See my vimrc for why I do this
bindkey -M viins hh vi-cmd-mode

# Ensure backspace continues to work in insert mode
bindkey '^?' backward-delete-char

# Disable traditional escape and arrow keys.
bindkey -rM viins "^["
bindkey -rpM viins "^["
bindkey -rM vicmd "^["
bindkey -rpM vicmd "^["

# Show if we are in normal mode.
function zle-line-init zle-keymap-select () {
if [[ "$KEYMAP" == "vicmd" ]]; then
  RESULT="N"
else
  RESULT="I"
fi

set-editing-mode "$RESULT"

COLOR="$fg[$FEATURE_COLORS[$(nice-hostname)]]"
PS1="$(command whoami)@%{$COLOR%}$(nice-hostname)%{$reset_color%} in %1d$(git-prompt-info)
[%{$COLOR%}$(get-editing-mode)%{$reset_color%}]â†’ "

zle reset-prompt
}

zle -N zle-line-init
zle -N zle-keymap-select

unset zle_bracketed_paste

## Changing Directories

# If a command cannot be executed, try cd.
#
# This is an old Fish option that I sometimes made use of.
setopt auto_cd

# Use pushd instead of cd
#
# Pushd is a thing that maintains a history of directories in a stack.
# It turns out that this is incredibly useful.
setopt auto_pushd

# Resolve links to their actual directory.
#
# Not doing this causes several unpleasant conflicts. Fish made the
# right call by not doing this. See:
#
#  http://fishshell.com/docs/current/faq.html#faq-cwd-symlink
#
#  > ...it is impossible to consistently keep symlinked directories
#  > unresolved. It is indeed possible to do this partially, and many
#  > other shells do so. But it was felt there are enough serious corner
#  > cases that this is a bad idea. Most such issues have to do with how
#  > '..' is handled...
setopt chase_links

# Do not print the directory stack on each pushd (cd)
setopt pushd_silent

# Pushd with no arguments is like cd with no arguments
setopt pushd_to_home

## History

# Save history between sessions.
#
# Zsh doesn't do this by default, and I don't know why.
HISTSIZE=10000
SAVEHIST=10000
HISTFILE="$HOME/.zsh_history"

# Don't beep at me when I do something wrong
setopt no_hist_beep

# Tell Z Shell to append to the history file.
#
# The other option is to write to it each session.
setopt append_history

# Store more information in the history file.
#
# This option will store the timestamp corresponding to when the
# command started, as well as its duration. I'm turning this on
# because I don't see why I wouldn't want more information.
setopt extended_history

# Apparently, there is a bug in the way Z Shell handles words.
#
# This option enforces correct behaviour, but can be slower. We'll try
# to do things correctly and see if it's slow.
setopt hist_lex_words

alias pbcopy='xclip -selection clipboard'
alias pbpaste='xclip -selection clipboard -o'
